function guiHandles=MICSStatusCheck(hgs,varargin)
%MICSStatusCheck Gui to check software and hardware of handpiece, pedal, and anspach motor
%
% Syntax:
%   MICSStatusCheck(hgs,simulateFlag)
%
% Notes:
%   This script will enable the MICS, prompt the user to press the
%   trigger, and collect data.  Then it will disable the MICS and continue
%   to collect data.  MICS shall spin at a certain RPM during the first
%   stage and have limited current draw.  During the second stage it shall
%   not spin
%
% See also:
%   hgs_robot
%

%
% $Author: jforsyth $
% ERROR: date, time not autogenerated

% Set network to static voyager if PC (add pause to ensure connection)
if ispc && ~strcmp(hgs.host, '10.1.1.178')
    setup_network('STATIC_VOYAGER');
    wb_open = waitbar(0,'Updating IP address to static 10.1.1.150. Please wait...');
    for iwait_open = 1:50
        pause(.1);
        waitbar(iwait_open/50,wb_open,'Updating IP address to static 10.1.1.150. Please wait...');
    end
    close(wb_open);
end

% Checks for arguments if any.  If none connect to the default robot
defaultRobotConnection = false;

% initialize real data collection
realData = 1;

if nargin<1
    hgs = hgs_robot('10.1.1.178'); % connection through voyager port
    if isempty(hgs)
        guiHandles='';
        return;
    end
    
    % maintain a flag to establish that this connection was done by this
    % script
    defaultRobotConnection = true;
elseif(nargin > 1 && strcmp(varargin(1),'simulate'))
    hgs = [];
    realData = 0;
end

if(realData)
    log_message(hgs,sprintf(['MICS Status Check Started ']));
else
    % do nothing
end

% Setup Script Identifiers for generic GUI
guiHandles = generateMakoGui('MICS Status Check',[],hgs,false);

% Setup the main function
set(guiHandles.mainButtonInfo,'CallBack',@updateProcedureCallback);

%override the default close callback for clean exit.
set(guiHandles.figure,'CloseRequestFcn',@MICSCheck_exit);

% Setup userdata structure to pass data between guis if need be
userDataStruct.results=-1;
set(guiHandles.figure,'UserData',...
    userDataStruct);

% Homing check done at the Cutter Test level.

% Disable during setup
set(guiHandles.mainButtonInfo,'Enable','off');
isProcedureCanceled = false;

%var
numTries = 1;

if(realData)
    % get arm hardware version
    armHardwareVersion=hgs.ARM_HARDWARE_VERSION;
else
    armHardwareVersion = 3.0;
end

% Setup Test paramters.  These are a structure in the format
testParamFields = {'TestName','TestFunction'};

simWarnings = {};
simErrors = {};
% Parameters to simulate
if(realData)
    % simulate nothing
else
    allWarnings = {'Voltage','Irrigation','Temperature','Current','Speed (enable)','Speed (disable)','FW_warning'};
    allErrors = {'Voltage','Irrigation','Temperature','Current','Speed (enable)','Speed (disable)','FW_fault'};
    simWarnings = {'Irrigation','Current'};
    %simErrors = {'ABC'};
end

switch int32(armHardwareVersion * 10 + 0.05)
    case 23 % 2.3
        
        runTest = [1];
        
        testParams = {...
            'MICS Check',@MICSCheck;...
            };
    case 30 % 3.0
        
        runTest = [1];
        
        testParams = {...
            'MICS Check',@MICSCheck;...
            };
    otherwise
        userDataStruct.results=-1;
        presentMakoResults(guiHandles,'FAILURE',...
            sprintf('Invalid hardware version %.1f',armHardwareVersion));
	log_results(hgs,'MICS Status Check','FAIL',...
	    sprintf('Invalid hardware version %.1f',armHardwareVersion));
	return
end

testIndex = 0;
ind = find(runTest);

% determine last test index
if(isempty(ind))
    lastTest = 0;
else
    lastTest = max(ind);
end

testParamStruct = cell2struct(testParams,testParamFields,2);

% General constants
WARN_KEY = 'warning';
ERROR_KEY = 'fault';
expectedReadTime = [];

% limit constants

% irrigation voltage
if(realData)
    % irrigation to be set by MICS function
else
    % hardcode irrigation value
    irrigation_expected = 10.2;
    irrigation_warning_lower = irrigation_expected-1.9;
    irrigation_warning_upper = irrigation_expected+0.9;
end

% current
curr_warning_lower = 0;
curr_warning_upper = 2.2;

% speed while enabled
spd_en_expected = 12000;
spd_en_warning_lower = spd_en_expected*0.95;
spd_en_warning_upper = spd_en_expected*1.05;
spd_en_error_lower = spd_en_expected*.9;
spd_en_error_upper = spd_en_expected*1.1;

% speed while disables
spd_dis_error_lower = 0;
spd_dis_error_upper = 100;


if(realData)
    % gather required data from arm
    endEffectorTransform = eye(4);
    endEffectorTransform(1:3,4) = hgs.CALIB_BALL_A';
else
    % skip
end

% Generate the GUI
for i=1:length(testParamStruct) %#ok<FXUP>
    
    if(realData)
        % display CRISIS version number
        swVersion = uicontrol(guiHandles.uiPanel,...
            'Style','text',...
            'String',sprintf('Arm Software version: %s',cell2mat(comm(hgs,'version_info'))),...
            'Units','normalized',...
            'HorizontalAlignment','center',...
            'FontUnits','normalized',...
            'FontSize',0.5,...
            'Position',[ .05 .875 .9 .075]...
            ); %#ok<AGROW>
    else
        % skip version display
    end
    
    % enable
    set(guiHandles.mainButtonInfo,'Enable','on');
    
    timerObj=timer;
    timerObj1=timer;
    
end


boxPosition = [0.35 0.3 0.3 0.05];

% generate a region to show progress
dispAxis = axes(...
    'Parent',guiHandles.uiPanel,...
    'Color','white',...
    'Position',boxPosition,...
    'XLim',[0 1],...
    'YLim',[0 1],...
    'Box','on',...
    'ytick',[],...
    'xtick',[] );

% Generate the required patches for joint in range status
progressBar = patch(...
    'Parent',dispAxis,...
    'XData',[0 0 0 0],...
    'YData',[0 0 1 1],...
    'FaceColor','blue'...
    );

% txt for progress bar
progressTxt = uicontrol(guiHandles.uiPanel,...
    'Style','text',...
    'Units','normalized',...
    'Position',boxPosition + [0 .1 0 0],...
    'FontUnits','normalized',...
    'FontSize',0.8,...
    'HorizontalAlignment','center',...
    'String','Progress');

setProgressOff();

if(realData)
% A log file is used to create Hass error log
logFileName=['MICS-ERROR-LOG-',...
    hgs.name,'-',...
    datestr(now,'yyyy-mm-dd-HH-MM'),'.txt'];
fullLogFileName = fullfile(guiHandles.reportsDir,logFileName);
else
logFileName=['MICS-ERROR-LOG-',...
    'UNNAMED','-',...
    datestr(now,'yyyy-mm-dd-HH-MM'),'.txt'];
fullLogFileName = fullfile(guiHandles.reportsDir,logFileName);    
end
%--------------------------------------------------------------------------
% Internal function to start test
%--------------------------------------------------------------------------
    function updateProcedureCallback(varargin)
        % preparre to start test
        if(runTest(testIndex+1))
            updateMainButtonInfo(guiHandles,'pushbutton',...
                sprintf('Click to start %s test',testParamStruct(testIndex+1).TestName),...
                @ArmSoftwareTestProcedure);
        elseif( (testIndex) == lastTest)
            resultsCallback;
        else
            testIndex = testIndex + 1;
            updateProcedureCallback;
        end
    end
%--------------------------------------------------------------------------
% Internal function to end test
%--------------------------------------------------------------------------

    function resultsCallback(varargin)
        try
            % Tests are complete analyse results
            resultString = {};
            for i=1:length(testParamStruct) %#ok<FXUP>
                if(~isempty(testParamStruct(i).failureMsg.error))
                    resultString{end+1} = sprintf('%s\n',...
                        testParamStruct(i).failureMsg.error);
                else
                    resultString{end+1} = sprintf('%s\n',...
                        testParamStruct(i).failureMsg.warning);
                end
                if(realData)
                    log_message(hgs,sprintf(['MICS Status Tool (%i): %i '],i,testParamStruct(i).results));
                else
                    % skip log
                end
            end
            appendToLogFile(fullLogFileName, cell2mat(resultString));
            
            % 'All Pass'
            if(all([testParamStruct(:).results] == 1) && strcmp(testParamStruct(:).dripTurning,'Yes')) % all pass, pass
                userDataStruct.results=1;
                presentMakoResults(guiHandles,'SUCCESS',...
                    resultString);
                if(realData)
                    log_results(hgs,'MICS Status Check','PASS','MICS Status Check successful');
                else
                    % skip log
                end
            elseif(any([testParamStruct(:).results] == 0)) % any failures
                % 'any failures'
                userDataStruct.results=-1;
                presentMakoResults(guiHandles,'FAILURE',...
                    resultString);
                if(realData)
                    log_results(hgs,'MICS Status Check','FAIL','MICS Status Check fail');
                else
                    % skip log
                end
            elseif(any(strcmp(testParamStruct(:).dripTurning,'No')))
                presentMakoResults(guiHandles,'FAILURE','Irrigation Motor Not Running');
                if(realData)
                    log_results(hgs,'MICS Status Check','FAIL','MICS Status Check fail');
                else
                    % skip log
                end
            else
                % warnings and pass results
                userDataStruct.results=2;
                presentMakoResults(guiHandles,'WARNING',...
                    resultString);
                if(realData)
		    log_results(hgs,'MICS Status Check','WARNING',...
		    	'MICS Status Check warning');
                else
                    % skip log
                end
            end
            
            try
                set(guiHandles.figure,'UserData',userDataStruct);
            catch
            end
            
        catch erm
            f = errordlg(erm.message, 'Error Dialog');
        end
        
    end
%--------------------------------------------------------------------------
% Internal function to change test
%--------------------------------------------------------------------------
    function ArmSoftwareTestProcedure(varargin)
        
        % set mainbutton to text
        set(guiHandles.mainButtonInfo,'style','text');
        
        % increment testIndex
        testIndex = testIndex+1;
        
        if(runTest(testIndex))
            
            % execute the function
            for i=1:numTries
                if(~isProcedureCanceled)
                    try
                        if( iscell(testParamStruct(testIndex).TestFunction) )
                            [testParamStruct(testIndex).results testParamStruct(testIndex).failureMsg testParamStruct(testIndex).dripTurning] = feval(...
                                testParamStruct(testIndex).TestFunction{:});
                        else
                            [testParamStruct(testIndex).results testParamStruct(testIndex).failureMsg testParamStruct(testIndex).dripTurning] = feval(...
                                testParamStruct(testIndex).TestFunction);
                            testParamStruct(testIndex).TestFunction;
                        end
                    catch
                        testParamStruct(testIndex).results = 0;
                    end
                end
                if(~isProcedureCanceled)
                    % break if passed before the end of the loop
                    if testParamStruct(testIndex).results == 1
                        break;
                    else
                        if i<numTries
                            % Retry message
                            if strcmp(questdlg(...
                                    'Retry test?','Retry Question',...
                                    'Yes','No',...
                                    'Yes'),'No')
                                break;
                            end
                        end
                    end
                end
            end
            if(~isProcedureCanceled)
                testParamStruct(testIndex).testComplete = true;
                
            end
            
        end
        if(~isProcedureCanceled)
            % reenable mainbutton
            set(guiHandles.mainButtonInfo,'style','pushbutton');
            
            % Check if this was the last test.  Analyse results
            if testIndex<length(testParamStruct)
                updateProcedureCallback;
            else
                
                if(realData)
                    % If i got here text succeeded
                    comm(hgs,'watchdog','OFF');
                    comm(hgs,'burr','DISABLE');
                else
                    % skip
                end
                
                    resultsCallback;
                set(guiHandles.figure,'CloseRequestFcn',@MICSCheck_exit);
                
            end
        end
    end
%--------------------------------------------------------------------------
% internal function to get tip position from robot
%--------------------------------------------------------------------------
    function [tipPosition,tipTransform] = getTipPosition
        tipTransform = reshape(hgs.flange_tx,4,4)' * endEffectorTransform;
        tipPosition = tipTransform(1:3,4)';
    end
%--------------------------------------------------------------------------
% Internal function to check communication with MICS
%--------------------------------------------------------------------------
    function [testResult failureMsg dripTurning] = MICSCheck(varargin)
        
        try
            
            setProgressOn();
            
            motor_current = 0;
            bus_voltage = 0;
            speed = 0;
            temperature = 0;
            irrigation_voltage = 0;
            faultBuffer = 0;
            
            if(realData)
                
                %guide user to enable arm
                robotFrontPanelEnable(hgs,guiHandles);
                
                
                % go to position where MICS gravity with out MICS attached
                % would go
                updateMainButtonInfo(guiHandles,'text',...
                        'Please be mindful of the arm. Moving arm to test position...' );
                    pause(2);
                go_to_position(hgs,[0  -55   0   75  -90   90]*pi/180,.2);
                
                try
                    % set gravity MICS
                    comm(hgs,'set_gravity_constants','MICS');
                catch
                    log_message(hgs,'set gravity MICS unsupported, loading CRISIS','WARNING'); %indicate warning to logs
                    try
                        hgs = LoadNGo(); % load CRISIS version which supports MICS
                        robotFrontPanelEnable(hgs,guiHandles);  %guide user to enable arm
                        comm(hgs,'set_gravity_constants','MICS'); % reattempt setting gravity constants to MICS
                    catch
                        log_message(hgs,'MICS CRISIS loadngo unsuccessful','ERROR'); %indicate error to logs
                        return;
                    end
                    set(swVersion,'String',sprintf('Arm Software version: %s',cell2mat(comm(hgs,'version_info')))); % set CRISIS version to latest version
                    
                end
                
                % reset haptic objects
                reset(hgs);
                
                % create a huge cube to allow burr to be turned on
                createHapticCube();
                
            else
                % skip setup
            end
            
            %Create a timer object to avoid watchdog error
            timerObj=timer('Period',0.05,'TimerFcn',@watchdogKeepAliveFcn,...
                'ExecutionMode','fixedRate');
            start(timerObj);
            
            if(realData)
                
                updateMainButtonInfo(guiHandles,'text',...
                    sprintf('Collecting Status...'));
                drawnow;
                
                %create a mics object
                mics = mako_mics();
                
                % read irrigation
                indIr = 4; % index of selected irrigation
                mics.irrigation = indIr;
                irrigation_expected = mics.irrigationNominalVoltages(indIr);
                log_message(hgs,sprintf('Irrigation set manually (%2.1f) V',irrigation_expected),'MESSAGE');
                irrigation_warning_lower = irrigation_expected-1.9;
                irrigation_warning_upper = irrigation_expected+0.9;
                
                % Ask user to hold down hand trigger
                %enable the cutter,such that cutter can be turned on.
                comm(hgs,'watchdog','ON');
                comm(hgs,'burr','ENABLE');
                
                for j = 1 : 5
                    updateMainButtonInfo(guiHandles,'text',...
                        sprintf('Holding down hand switch, data collecting start in %d seconds...',5 - j));
                    drawnow;
                    pause(1);
                end
                updateMainButtonInfo(guiHandles,'text',...
                    {'Continue holding down hand switch for about 10 seconds, data collecting...'});
                drawnow;
                
                % set samples and progress update timer
                mics.number_of_samples = 1000; % which takes about 10 seconds
                
                expectedReadTime = 12; % expected collection time
                loopTic = tic;
                %Create a timer object to update progress bar
                timerObj1=timer('Period',0.1,'TimerFcn',@progressUpdateFcn,...
                    'ExecutionMode','fixedRate');
                start(timerObj1);
                
                % enable MICS and collect data
                mics_data = mics.stream_data;
                motor_current = mics_data(:,1);
                speed = mics_data(:,3);
                
                len_irr_read = length(mics_data(:,6));
                req_irr = 20; % samples to read from the end of the irrigation data per ES-ROB-0169
                if(len_irr_read < req_irr)
                    log_message(hgs,'Irrigation read length < 20 samples','WARNING');
                    irrigation_voltage = mics_data(1:len_irr_read,6);
                else
                    % read full required data
                    irrigation_voltage = mics_data(len_irr_read-req_irr+1:len_irr_read,6);
                end
                
                %get the fault as well
                faultBuffer = mics.fault;
                
            else
                % skip burr enable, data collection
            end
            
            %initialize to success case, warning/error will override
            testResult = 1;
            failureMsg.error = '';
            failureMsg.warning = '';
            
            if(realData)
                % record free running burr current
                log_message(hgs,sprintf('mics free running curr: %2.1f A',mean(motor_current)),'MESSAGE');
            end
            
            %check for errors
            [testResult, failureMsg] = MICS_enable_error_check(faultBuffer,testResult,failureMsg);
            
            %check for warnings
            [testResult, failureMsg] = MICS_enable_warning_check(faultBuffer,testResult,failureMsg);
            
            if(realData)
                % disable MICS and collect data
                comm(hgs,'watchdog','OFF');
                comm(hgs,'burr','DISABLE');
                
                % allow spindown
                pause(1);
                
                %collect data
                mics.number_of_samples = 250; % which takes about 5 seconds
                mics_data = mics.stream_data;
                speed = mics_data(:,3);
                
            else
                % skip burr disable, data collection
            end
            
            if(realData)
                %clear the object.
                delete(mics);
                %clear timer
                stop_clear_timer(timerObj);
                stop_clear_timer(timerObj1);
                mics = [];
                set(progressBar,...
                    'XData',[0 1 1 0]);
                drawnow;
                pause(0.5);
                
            else
                % skip mics clear
            end
            
            setProgressOff(); % close display of bar
            updateMainButtonInfo(guiHandles,'text',...
                {'Data collection complete'});
            drawnow;
            dripTurning=questdlg(...
                'Was the drip motor / irrigation pump turning?',...
                'Drip Test','Yes','No','Yes');
            
            %check for errors
            [testResult, failureMsg] = MICS_disable_error_check(faultBuffer,testResult,failureMsg);
            
            reset(hgs); % clear haptic data
            
            % save all the data for offline processing if needed
            dataFileName  = ['MICSStatusCheck-' datestr(now,'yyyy-mm-dd-HH-MM')];
            fullDataFileName = fullfile(guiHandles.reportsDir,dataFileName);
            save(fullDataFileName,'testResult', 'failureMsg');
            
        catch erm
            setProgressOff(); % close display of bar
            % got an error so fail the test
            testResult = 0;
            f = errordlg(erm.message, 'Error Dialog');
            if(realData)
                log_message(hgs,erm.message,'ERROR');
                %clear the object.
                comm(hgs,'watchdog','OFF');
                comm(hgs,'burr','DISABLE');
                delete(mics);
                %clear timer
                stop_clear_timer(timerObj);
                stop_clear_timer(timerObj1);
                mics = [];
            else
                % skip log, disable, delete
            end
            
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to keep the watchdog alive
        %--------------------------------------------------------------------------
        function watchdogKeepAliveFcn(varargin)
            % do a basic query to keep the watchdog happy
            try
                comm(hgs,'ping_control_exec');
            catch it
                %do nothing
            end
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to stop and clear timer
        %--------------------------------------------------------------------------
        function stop_clear_timer(timerObj)
            %stop and delete the time object
            if(isvalid(timerObj))
                %stop the timer object
                stop(timerObj);
                %delete the timer object from memory
                delete(timerObj);
                %clear the timer object from workspace
                clear timerObj;
            end
        end
        
        
        %--------------------------------------------------------------------------
        %   Internal function to update progress bar
        %--------------------------------------------------------------------------
        function progressUpdateFcn(varargin)
            
            try
                % update progress bar
                timeLoop = toc(loopTic);
                ratio = timeLoop/expectedReadTime;
                ratio = max(0,ratio);
                ratio = min(1,ratio);
                set(progressBar,...
                    'XData',[0 ratio ratio 0]);
                drawnow;
            catch it
                %do nothing
            end
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to check warnings
        %--------------------------------------------------------------------------
        
        function [testResult, failureMsg] = MICS_enable_warning_check(faultBuffer,testResult,failureMsg)
            try
                
                irrigation = abs(mean(irrigation_voltage));
                [testResult, failureMsg] = warning_check(faultBuffer,testResult,failureMsg,'Irrigation',irrigation,irrigation_warning_upper,irrigation_warning_lower);
                
                curr = abs(mean(motor_current));
                [testResult, failureMsg] = warning_check(faultBuffer,testResult,failureMsg,'Current',curr,curr_warning_upper,curr_warning_lower);
                
                spd = abs(mean(speed));
                [testResult, failureMsg] = warning_check(faultBuffer,testResult,failureMsg,'Speed (enable)',spd,spd_en_warning_upper,spd_en_warning_lower);
                
                if(realData)
                    faultIndices = find(faultBuffer > 0);
                    if(~isempty(faultIndices))
                        logIndex = log2(double(faultBuffer(faultIndices(1)))) + 1;
                        % check it is warning
                        msg = mics.fault_message{logIndex};
                        if(strfind(msg,WARN_KEY))
                            failureMsgTMP=sprintf(...
                                'MICS enable FW warn <%s>',msg);
                            if(realData)
                                log_message(hgs,failureMsgTMP,'WARNING');
                            else
                                % skip log
                            end
                            failureMsg.warning = sprintf('%s %s\n',failureMsg.warning,failureMsgTMP);
                            if(testResult ~= 0) %skip if failure has been detected prior
                                testResult = -2;
                            end
                        end
                    end
                    
                else
                    % simulate fault
                    % check it is warning
                    if(simulateWarning('FW_warning'))
                        msg = sprintf('simulated mics %s',WARN_KEY);
                    else
                        msg = '';
                    end
                    if(strfind(msg,WARN_KEY))
                        failureMsgTMP=sprintf(...
                            'MICS enable FW warn <%s>',msg);
                        if(realData)
                            log_message(hgs,failureMsgTMP,'WARNING');
                        else
                            % skip log
                        end
                        failureMsg.warning = sprintf('%s %s\n',failureMsg.warning,failureMsgTMP);
                        if(testResult ~= 0) %skip if failure has been detected prior
                            testResult = -2;
                        end
                    end
                end
                
            catch
                testResult = 0;
                failureMsg.error = sprintf('Error checking %s\n',string);
            end
        end
        
        
        %--------------------------------------------------------------------------
        %   Internal function to check errors
        %--------------------------------------------------------------------------
        
        function [testResult, failureMsg] = MICS_enable_error_check(faultBuffer,testResult,failureMsg)
            try
                
                spd = abs(mean(speed));
                [testResult, failureMsg] = error_check(faultBuffer,testResult,failureMsg,'Speed (enable)',spd,spd_en_error_upper,spd_en_error_lower);
                
                if(realData)
                    faultIndices = find(faultBuffer > 0);
                    if(~isempty(faultIndices))
                        logIndex = log2(double(faultBuffer(faultIndices(1)))) + 1;
                        % check it is error
                        msg = mics.fault_message{logIndex};
                        if(strfind(msg,ERROR_KEY))
                            failureMsgTMP=sprintf(...
                                'MICS enable FW fault <%s>',msg);
                            if(realData)
                                log_message(hgs,failureMsgTMP,'ERROR');
                            else
                                % skip log
                            end
                            failureMsg.error = sprintf('%s %s\n',failureMsg.error,failureMsgTMP);
                            testResult = 0;
                        end
                    end
                else
                    % simulate fault
                    % check it is error
                    if(simulateError('FW_fault'))
                        msg = sprintf('simulated mics %s',ERROR_KEY);
                    else
                        msg = '';
                    end
                    if(strfind(msg,ERROR_KEY))
                        failureMsgTMP=sprintf(...
                            'MICS enable FW fault <%s>',msg);
                        if(realData)
                            log_message(hgs,failureMsgTMP,'ERROR');
                        else
                            % skip log
                        end
                        failureMsg.error = sprintf('%s %s\n',failureMsg.error,failureMsgTMP);
                        testResult = 0;
                    end
                end
                
            catch
                testResult = 0;
                failureMsg.error = sprintf('Error checking %s\n',string);
            end
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to check errors
        %--------------------------------------------------------------------------
        
        function [testResult, failureMsg] = MICS_disable_error_check(faultBuffer,testResult,failureMsg)
            try
                spd = abs(mean(speed));
                [testResult, failureMsg] = error_check(faultBuffer,testResult,failureMsg,'Speed (disable)',spd,spd_dis_error_upper,spd_dis_error_lower);
            catch
                testResult = 0;
                failureMsg.error = sprintf('Error checking %s\n',string);
            end
        end
        
        
        %--------------------------------------------------------------------------
        %   Internal function to handle warnings
        %--------------------------------------------------------------------------
        
        function [testResult, failureMsg] = warning_check(faultBuffer, testResult, failureMsg, string, value, warning_upper, warning_lower)
            try
                if( realData && ( value > warning_upper || value < warning_lower) ...
                        || (~realData && simulateWarning(string) ) )
                    failureMsgTMP = sprintf('%s %1.2f, range (%1.2f : %1.2f)',string, value, warning_lower, warning_upper);
                    if(realData)
                        log_message(hgs,failureMsgTMP,'WARNING');
                    else
                        % skip log
                    end
                    failureMsg.warning = sprintf('%s %s\n',failureMsg.warning,failureMsgTMP);
                    if(testResult ~= 0) %skip if failure has been detected prior
                        testResult = -2;
                    end
                end
            catch
                testResult = 0;
                failureMsg.error = sprintf('Error checking %s\n',string);
            end
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to handle errors
        %--------------------------------------------------------------------------
        
        function [testResult, failureMsg] = error_check(faultBuffer, testResult, failureMsg, string, value, error_upper, error_lower)
            try
                
                if( realData && ( value > error_upper || value < error_lower) ...
                        || (~realData && simulateError(string) ) )
                    failureMsgTMP = sprintf('%s %1.2f, range (%1.2f : %1.2f)',string, value, error_lower, error_upper);
                    if(realData)
                        log_message(hgs,failureMsgTMP,'ERROR');
                    else
                        % skip log
                    end
                    failureMsg.error = sprintf('%s %s\n',failureMsg.error,failureMsgTMP);
                    testResult = 0;
                end
            catch
                testResult = 0;
                failureMsg.error = sprintf('Error checking %s\n',string);
            end
        end
        
        
        %--------------------------------------------------------------------------
        %   Internal function to simulate errors
        %--------------------------------------------------------------------------
        
        function errBool = simulateError(testString)
            
            errBool = 0;
            
            for i = 1:length(simErrors)
                if(strcmp(testString,simErrors{i}))
                    errBool = 1;
                end
            end
            
        end
        
        %--------------------------------------------------------------------------
        %   Internal function to simulate warnings
        %--------------------------------------------------------------------------
        
        function errBool = simulateWarning(testString)
            
            errBool = 0;
            
            for i = 1:length(simWarnings)
                if(strcmp(testString,simWarnings{i}))
                    errBool = 1;
                end
            end
            
        end
        
        %--------------------------------------------------------------------------
        % Internal function to create a haptic cube
        %--------------------------------------------------------------------------
        function createHapticCube(varargin)
            vertices = [ -0.12 0.12 0.12 -0.12 -0.12 -0.10 -0.10 0.10 0.10 -0.10 ]*100;
            numVerts = length(vertices)/2;
            flateye = eye(4);
            [objPos, objTransform] = getTipPosition;
            
            hapticObj = hgs_haptic(hgs,'extruded_2Dpoly___abcd',...
                'verts',vertices,...
                'numVerts',numVerts,...
                'stiffness',10000,...
                'damping',20.0,...
                'haptic_wrt_implant',flateye(:),...
                'obj_wrt_ref',objTransform,...
                'forceMax',80,...
                'torqueMax',4,...
                'constrPlaneGain',42,...
                'start_end_cap',[-2 2],...
                'constrPlaneNormal',[0.0 0.0 0.1],...
                'planarConstrEnable',0,...
                'safetyConstrEnable',0,...
                'safetyPlaneNormal',[0.0 0.0 1.0],...
                'safetyConstrDir',1,...
                'planarConstrDir',1 ...
                );
            
            mode(hgs,'haptic_interact',...
                'end_effector_tx',endEffectorTransform,...
                'vo_and_frame_list',hapticObj.name,...
                'burr_prereq_obj_name','extruded_2Dpoly___abcd',...
                'burr_prereq_var_name','hapticMode',...
                'burr_prereq_value',1);
            
        end
        
    end

%--------------------------------------------------------------------------
% internal function: close GUI, overide the default exit button callback
%--------------------------------------------------------------------------
    function MICSCheck_exit(varargin)
        %set phasing cancel flag
        isProcedureCanceled=true;
        try
            if(realData)
                reset(hgs); % clear haptic data
                mode(hgs,'zerogravity','ia_hold_enable',1);
                % If i got here text succeeded
                comm(hgs,'watchdog','OFF');
                comm(hgs,'burr','DISABLE');
                stop_clear_timer(timerObj)
                stop_clear_timer(timerObj1)
            end
            setProgressOff(); % close display of bar
        catch
        end
        % close the connection if it was established by this script
        if defaultRobotConnection
            close(hgs);
        end
        closereq;
        if ispc
            setup_network('STATIC');
            wb_close = waitbar(0,'Updating IP address to static 172.16.16.150. Please wait...');
            for iwait_close = 1:50
                pause(.1);
                waitbar(iwait_close/50,wb_close,'Updating IP address to static 172.16.16.150. Please wait...');
            end
            close(wb_close);
        end
    end

%--------------------------------------------------------------------------
% internal function: set progress bar and txt on
%--------------------------------------------------------------------------
    function setProgressOn()
        set(progressTxt,'Visible','on')
        set(progressBar,'Visible','on')
        set(dispAxis,'Visible','on')
    end

%--------------------------------------------------------------------------
% internal function: set progress bar and txt off
%--------------------------------------------------------------------------
    function setProgressOff()
        set(progressTxt,'Visible','off')
        set(progressBar,'Visible','off')
        set(dispAxis,'Visible','off')
    end

%--------------------------------------------------------------------------
% internal function: append message to log file
%--------------------------------------------------------------------------
    function appendToLogFile(fileName, logMsg)
        [fid, message] = fopen(fileName, 'a');
        if fid == -1
            errordlg(sprintf(['Cannot create/open log file %s  \n %s \n Exiting Hass ' ...
                'Test.'], fileName, message),'HASS Test');
            return;
        end
        fprintf(fid, '%s\n', logMsg);
        fclose(fid);
    end


end
%
%
% --------- END OF FILE ----------
